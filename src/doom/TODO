Every use of:

create_struct is only used in textscreen, in theory everything could be moved to new/delete in there

Zone Allocator: Make Z_Delete run the destructors without lambda when it can.

All string manipulation to std::string and stringview with M_StringDuplicate for compat

Remove M_StringDuplicate/free and replace with string or unique_ptr<char[]>

memcpy => std::copy
memset => std::fill or default init {}
mommove gone from src/doom, just networking ones left.

examine sector_t::specialdata void*, std::variant is awkward, made into a std::any, consider variant
May be able to use same type as thinkers list

move mobj_t builtin lists to std::lists

any c-style cast" "-Wold-style-cast" in `/githug/cpp-doom/CMakeLists.txt

any void* -
S_Sound... takes liberties with void*


review all uses of c_str

review all use of taking std::string as a parameter with a view to using std::string_view


rm -rf ~/github/cpp-doom/debug
mkdir ~/github/cpp-doom/debug
cd ~/github/cpp-doom/debug
cp ../build/doom1.wad .
export CC=/usr/bin/clang-10
export CXX=/usr/bin/clang++-10
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_BUILD_TYPE=Debug ..

( cd ~/github/cpp-doom/src ; echo *.cpp doom/*.cpp | xargs clang-rename-10 -qualified-name=texture_name_t -new-name=lump_name_t   -p=~/github/cpp-doom/debug )


rm -rf ~/github/cpp-doom/asan
mkdir ~/github/cpp-doom/asan
cd ~/github/cpp-doom/asan
cp ../build/doom1.wad .
export CC=/usr/bin/clang-10
export CXX=/usr/bin/clang++-10
cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS="-fsanitize=address  -fsanitize=leak -g" -DCMAKE_C_FLAGS="-fsanitize=address  -fsanitize=leak -g" -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=address  -fsanitize=leak" -DCMAKE_MODULE_LINKER_FLAGS="-fsanitize=address  -fsanitize=leak"

( cd ~/github/cpp-doom/release/ ; make c++-doom -j 4 )
( cd ~/github/cpp-doom/release/ ; ~/github/cpp-doom/debug/src/c++-doom -timedemo demo1 -nogui )

( cd ~/github/cpp-doom/debug/ ; make c++-doom -j 4 )
( cd ~/github/cpp-doom/debug/ ; gdb ~/github/cpp-doom/debug/src/c++-doom )
( cd ~/github/cpp-doom/debug/ ; ~/github/cpp-doom/debug/src/c++-doom -timedemo demo1 -nogui )
( cd ~/github/cpp-doom/debug/ ; ~/github/cpp-doom/debug/src/c++-doom -loadgame 4 )

crispy physical menu is broken // not to do with libfmt in menu

load and save is mostly working, save names are garbled.
verified load of crsipy save works, and load of our own saves works,
haven't verified crispy will load our saves

angle_t is a real type with no implicit cast to int

fixed_t is a real type with an implicit cast to int, for now
fixed64_t inplace
any use of FRACBITS.size is discarding type info and should be fixed."


wikipedia
Non-equivalence of arithmetic right shift and division[edit]
However, arithmetic right shifts are major traps for the unwary, specifically in treating rounding of negative integers. For example, in the usual two's complement representation of negative integers, −1 is represented as all 1's. For an 8-bit signed integer this is 1111 1111. An arithmetic right-shift by 1 (or 2, 3, ..., 7) yields 1111 1111 again, which is still −1. This corresponds to rounding down (towards negative infinity), but is not the usual convention for division.

It is frequently stated that arithmetic right shifts are equivalent to division by a (positive, integral) power of the radix (e.g., a division by a power of 2 for binary numbers), and hence that division by a power of the radix can be optimized by implementing it as an arithmetic right shift. (A shifter is much simpler than a divider. On most processors, shift instructions will execute faster than division instructions.) Large number of 1960s and 1970s programming handbooks, manuals, and other specifications from companies and institutions such as DEC, IBM, Data General, and ANSI make such incorrect statements [8][page needed].

Logical right shifts are equivalent to division by a power of the radix (usually 2) only for positive or unsigned numbers. Arithmetic right shifts are equivalent to logical right shifts for positive signed numbers. Arithmetic right shifts for negative numbers in N−1's complement (usually two's complement) is roughly equivalent to division by a power of the radix (usually 2), where for odd numbers rounding downwards is applied (not towards 0 as usually expected).

Arithmetic right shifts for negative numbers are equivalent to division using rounding towards 0 in one's complement representation of signed numbers as was used by some historic computers, but this is no longer in general use.